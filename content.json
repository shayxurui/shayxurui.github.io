{"pages":[],"posts":[{"title":"人脸关键点基本操作函数","text":"总结关于人脸数据预处理的函数。 ##读取图片和关键点: image=PIL.Image.open(image_path) landmark=np.loadtxt(pts_path,skiprows=3,comments=’}’) #或者 landmarks = np.genfromtxt(pts_path, skip_header=3, skip_footer=1) ##根据关键点得到边界框: minx = int(landmarks[:, 0].min()) miny = int(landmarks[:, 1].min()) maxx = int(landmarks[:, 0].max()) maxy = int(landmarks[:, 1].max()) ##随机裁剪图片: h, w = image.shape[:2] new_h, new_w = output_size top = np.random.randint(0, h - new_h) left = np.random.randint(0, w - new_w) image = image[top: top + new_h,left: left + new_w] landmarks = landmarks - [left, top] ##提取人脸: image = image.crop([bbox[0] - pad, bbox[1] - pad, bbox[2] + pad, bbox[3] + pad]) landmarks = landmarks - (bbox[0] - pad, bbox[1] - pad) bbox是边界框坐标,bbox=(minx,miny,maxx,maxy).pad是多裁剪部分,关键点减去裁剪后的起始坐标. ##得到旋转矩阵: theta = np.radians(rotation_angle) c, s = np.cos(theta), np.sin(theta) mat = np.matrix(‘{} {} 0; {} {} 0’.format(c, -s, s, c), np.float32) mat=((cos,-sin,0),(sin,cos,0)) ##随机旋转图片: w, h = image.size image_rot = image.rotate(rotation_angle) w_rot, h_rot = image_rot.size center=(w/2,h/2) center_rot=(w_rot/2,h_rot/2) landmarks_rot=landmarks-center landmarks_rot = np.asarray(np.dot(landmarks_rot, manual_theta_inv)[:, :2]) landmarks_rot=landmarks_rot+center_rot manual_theta_inv是旋转矩阵. ##图片放缩: w, h = image.size image =torchvision.transforms.Resize((self.output_size, self.output_size))(image) landmarks = landmarks * [self.output_size / w, self.output_size / h] ##图片归一化: self.mean_img=np.mean(self.imgs,axis=(-3,-2)) self.std_dev_img=np.std(self.imgs,axis=(-3,-2)) self.imgs=(self.imgs-self.mean_img)/self.std_dev_img ##图片转换成张量: image=torchvision.transforms.ToTensor(image) landmarks=torch.from_numpy(landmarks).float().div(img_size) ##根据一个关键点，生成一个热点图: return np.zeros((heatmap.size, heatmap.size)) 如果关键点不可见，则返回全0矩阵 x_range = [i for i in range(heatmap.size)] y_range = [i for i in range(heatmap.size)] xx, yy = np.meshgrid(x_range, y_range) d2 = (xx - keypoint[0]) ** 2 + (yy - keypoint[1]) ** 2 xx是x_range的行扩展，yy是y_range的列扩展。xx-keypoint[0]，xx中第keypoint[0]列为0。yy-keypoint[1]，yy中第keypoint[1]行为0。d2,只有keypoint坐标下的值为0。 exponent = d2 / 2.0 / sigma / sigma heatmap = np.exp(-exponent) heatmap中只有关键点坐标值为1，其他坐标值皆小于1。 ##根据关键点生成热点图: landmarks = landmarks * [self.heatmap_size / image.size, self.heatmap_size / image.size] for i in range(68): flag = ~np.isnan(landmarks[i, 0]) heatmap=… heatmap = heatmap[np.newaxis, …] hearmaps.append(heatmap) flag:该关键点是否被遮挡，或者不可见。如果不可见，则landmark值为NaN。 ##测试误差 瞳孔距离: normDist = np.linalg.norm(np.mean(gtLandmarks[36:42], axis=0) - np.mean(gtLandmarks[42:48], axis=0)) 眼角距离: normDist = np.linalg.norm(gtLandmarks[36] - gtLandmarks[45]) 边界框对角线距离: height, width = np.max(gtLandmarks, axis=0) - np.min(gtLandmarks, axis=0) normDist = np.sqrt(width ** 2 + height ** 2) FAN的边界框对角线距离: height, width = np.max(gtLandmarks, axis=0) - np.min(gtLandmarks, axis=0) normDist=np.sqrt(width*height) 测试误差: err = np.mean(np.sqrt(np.sum((gtLandmarks - ptLandmarks) ** 2, axis=1))) / normDist ##左右翻转图片: 图片左右翻转: img=np.array(np.fliplr(img)) 关键点左右翻转: landmark[:,:,0]=img.size[1]-landmark[:,:,0] #把关键点的坐标置以图片的x坐标中点对称 ##扰动: 从正态分布随机产生一个弧度，均值为0，方差是给定的弧度 angel=np.random.normal(0,rotation_std_dev_radian) 正太分布的标准差，均值为0，随机产生偏移 offset=[np.random.normal(0,translation_std_dev_x),np.random.normal(0,translation_std_dev_y)] 随机产生放缩比例 scaling=np.random.normal(1,scale_std_dev) 旋转矩阵: R=np.array([[np.cos(angel),-np.sin(angel)],[np.sin(angel),np.cos(angel)]]) ##显示68个关键点在人脸中的位置: def drawLineChart(frame,i,j): for k in range(i,j-1): cv2.circle(frame,(preds[k,0],preds[k,1]),2,(255,255,255),-1) cv2.line(frame,(preds[k,0],preds[k,1]),(preds[k+1,0],preds[k+1,1]),(255,255,255),1) cv2.circle(frame,(preds[j-1,0],preds[j-1,1]),2,(255,255,255),-1) drawLineChart(frame,0,17) drawLineChart(frame,17,22) drawLineChart(frame,22,27) drawLineChart(frame,27,31) drawLineChart(frame,31,36) drawLineChart(frame,36,42) cv2.line(frame,(preds[41,0],preds[41,1]),(preds[36,0],preds[36,1]),(255,255,255),1) drawLineChart(frame,42,48) cv2.line(frame,(preds[47,0],preds[47,1]),(preds[42,0],preds[42,1]),(255,255,255),1) drawLineChart(frame,48,60) cv2.line(frame,(preds[59,0],preds[59,1]),(preds[48,0],preds[48,1]),(255,255,255),1) drawLineChart(frame,60,68) cv2.line(frame,(preds[67,0],preds[67,1]),(preds[60,0],preds[60,1]),(255,255,255),1) ##高斯图: ###高斯核: for i in range(height): for j in range(width): gauss[i][j] = amplitude math.exp(-(math.pow((j + 1 - center_x) / ( sigma_horz width), 2) / 2.0 + math.pow((i + 1 - center_y) / (sigma_vert * height), 2) / 2.0)) ###根据高斯核，生成高斯图: image=np.zeros((256,256)) point=landmark sigma=2 ul = [math.floor(point[0] - 3 * sigma), math.floor(point[1] - 3 * sigma)] #ul=[xmin-6,ymin-6] br = [math.floor(point[0] + 3 * sigma), math.floor(point[1] + 3 * sigma)] #br=[xmax-6,ymax+6] if (ul[0] &gt; image.shape[1] or ul[1] &gt; image.shape[0] or br[0] &lt; 1 or br[1] &lt; 1): return image size = 6 * sigma + 1 g = _gaussian(size) #高斯核 13*13 g_x = [int(max(1, -ul[0])), int(min(br[0], image.shape[1])) -int(max(1, ul[0])) + int(max(1, -ul[0]))] g_y = [int(max(1, -ul[1])), int(min(br[1], image.shape[0])) -int(max(1, ul[1])) + int(max(1, -ul[1]))] img_x = [int(max(1, ul[0])), int(min(br[0], image.shape[1]))] img_y = [int(max(1, ul[1])), int(min(br[1], image.shape[0]))] assert (g_x[0] &gt; 0 and g_y[1] &gt; 0) image[img_y[0] - 1:img_y[1], img_x[0] - 1:img_x[1]] = image[img_y[0] - 1:img_y[1], img_x[0] - 1:img_x[1]] + g[g_y[0] - 1:g_y[1], g_x[0] - 1:g_x[1]] #image[ymin-1:ymax,xmin-1:xmax]=image[ymin-1:ymax,xmin-1:xmax]+g[1-1:y_max-ymin+1,1-1:x_max-xmin+1] image[image &gt; 1] = 1 return image ##从热点图中得到关键点坐标： max, idx = torch.max( #max:(1,68) idx:(1,68) hm.view(hm.size(0), hm.size(1), hm.size(2) * hm.size(3)), 2) #(1,68,65536) idx += 1 preds = idx.view(idx.size(0), idx.size(1), 1).repeat(1, 1, 2).float() #preds:(1,68,2) preds[…, 0].apply_(lambda x: (x - 1) % hm.size(3) + 1) # x坐标. x=idx%hm.size(3) preds[…, 1].add_(-1).div_(hm.size(2)).floor_().add_(1) # y坐标. y=idx/hm.size(2) for i in range(preds.size(0)): #1 for j in range(preds.size(1)): #68 hm_ = hm[i, j, :] #(256,256) pX, pY = int(preds[i, j, 0]) - 1, int(preds[i, j, 1]) - 1 if pX &gt; 0 and pX &lt; 63 and pY &gt; 0 and pY &lt; 63: diff = torch.FloatTensor( [hm_[pY, pX + 1] - hm_[pY, pX - 1], hm_[pY + 1, pX] - hm_[pY - 1, pX]]) preds[i, j].add_(diff.sign_().mul_(.25)) preds.add_(-.5) preds_orig = torch.zeros(preds.size()) #preds_orig:(1,68,2) if center is not None and scale is not None: for i in range(hm.size(0)): for j in range(hm.size(1)): preds_orig[i, j] = transform( preds[i, j], center, scale, hm.size(2), True) return preds, preds_orig","link":"/2018/10/30/FaceAlignment/"},{"title":"maskrcnn阅读笔记","text":"这是我阅读Facebook发布基于pytorch1.0版本的mask r cnn所做的笔记。 #优化器 optimizer = make_optimizer(cfg, model) #得到学习率为0.02,权值衰减为0.0001，冲量是0.9的SGD优化器 def make_optimizer(cfg, model): params = [] for key, value in model.named_parameters(): if not value.requires_grad: #若值不需要梯度计算，则跳过这次循环 continue lr = cfg.SOLVER.BASE_LR # 0.02 weight_decay = cfg.SOLVER.WEIGHT_DECAY # 0.0001 if &quot;bias&quot; in key: lr = cfg.SOLVER.BASE_LR * cfg.SOLVER.BIAS_LR_FACTOR weight_decay = cfg.SOLVER.WEIGHT_DECAY_BIAS # 0.0001 params += [{&quot;params&quot;: [value], &quot;lr&quot;: lr, &quot;weight_decay&quot;: weight_decay}] optimizer = torch.optim.SGD(params, lr, momentum=cfg.SOLVER.MOMENTUM) #返回SGD优化器 return optimizer #学习率更新规则 scheduler = make_lr_scheduler(cfg, optimizer) def make_lr_scheduler(cfg, optimizer): return WarmupMultiStepLR( optimizer, cfg.SOLVER.STEPS, cfg.SOLVER.GAMMA, warmup_factor=cfg.SOLVER.WARMUP_FACTOR, warmup_iters=cfg.SOLVER.WARMUP_ITERS, warmup_method=cfg.SOLVER.WARMUP_METHOD, ) class WarmupMultiStepLR(torch.optim.lr_scheduler._LRScheduler): def __init__( self, optimizer, #SGD milestones, # (60000, 80000) gamma=0.1, # 0.1 warmup_factor=1.0 / 3, # 1.0/3 warmup_iters=500, # 500 warmup_method=&quot;linear&quot;, # &quot;linear&quot; last_epoch=-1, ): if not list(milestones) == sorted(milestones): raise ValueError( &quot;Milestones should be a list of&quot; &quot; increasing integers. Got {}&quot;, milestones, ) if warmup_method not in (&quot;constant&quot;, &quot;linear&quot;): raise ValueError( &quot;Only &apos;constant&apos; or &apos;linear&apos; warmup_method accepted&quot; &quot;got {}&quot;.format(warmup_method) ) self.milestones = milestones self.gamma = gamma self.warmup_factor = warmup_factor self.warmup_iters = warmup_iters self.warmup_method = warmup_method super(WarmupMultiStepLR, self).__init__(optimizer, last_epoch) def get_lr(self): warmup_factor = 1 if self.last_epoch &lt; self.warmup_iters: if self.warmup_method == &quot;constant&quot;: warmup_factor = self.warmup_factor elif self.warmup_method == &quot;linear&quot;: alpha = self.last_epoch / self.warmup_iters # -0.002 warmup_factor = self.warmup_factor * (1 - alpha) + alpha # 500.98 return [ base_lr* warmup_factor* self.gamma ** bisect_right(self.milestones, self.last_epoch) for base_lr in self.base_lrs ]","link":"/2018/10/30/maskrcnn阅读笔记/"}],"tags":[{"name":"deep learning","slug":"deep-learning","link":"/tags/deep-learning/"}],"categories":[]}